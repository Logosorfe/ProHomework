Существует класс Event со следующими полями:
    private int eventId; - сквозной порядковый номер для события, повторяющихся быть не
    должно
    private String userName;
    private String userIp;
    private LocalDate eventDate;
    private EventState eventState;
    Тип данных EventState это перечисления: SUCCESS,REQUESTERROR,ACCESSDENIED;

Существует класс EventCreator который создает событие имитирующее работу firewall
для определенного пользователя, пользователей в системе 10, все они работают
независимо друг от друга, работа пользователей продолжается до тех пор, пока не будет
послан сигнал стоп всем эмуляторам работы пользователя(используйте общую переменную типа
AtomicBoolean)

Существую четыре экземпляра класса FirewallEventListener, которые отвечают за разбор
списка событий создаваемых при работе пользователя. Все четыре обработчика работают
параллельно.
Что делает обработчик:
1. Получает событие из списка событий и записывает его в список логов в виде четырех строк
с интервалом в 1 мс.

"Обработчик " + имя обработчика + eventId + имя пользователя
"Обработчик " + имя обработчика + eventId + ип адрес пользователя
"Обработчик " + имя обработчика + eventId + дата и время запроса
"Обработчик " + имя обработчика + eventId + статус запроса

Обработчики работают пока в списке событий не останется не обработанных событий

После завершения всех обработчиков, отдельный поток должен вывести полученный
список логов в консоль;

Условия для корректного решения:

1. Каждые четыре строки для одного события должны идти подряд и не пересекаться
с другими строками других обработчиков в списке логов
2. Список событий очищать нельзя, каждый обработчик должен понимать какое по счету
событие из списка ему нужно взять
3. Если событие взял обработчик, то его никто более не может взять, в итоговом списке
логов не должно быть одного и того же события обработанных двумя и более обработчиками
4. Не использовать synchronized в сигнатуре методов, в остальных местах можно и нужно.
5. Список событий общий для всех, список логов общий для всех.