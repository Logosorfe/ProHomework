Существует класс Event со следующими полями:
    private int eventId; - сквозной порядковый номер для события, повторяющихся быть не
    должно
    private String userName;
    private String userIp;
    private LocalDate eventDate;
    private EventState eventState;
    Тип данных EventState это перечисления: SUCCESS, REQUEST_ERROR, ACCESS_DENIED;

Существует класс EventCreator который создает событие имитирующее работу firewall
для определенного пользователя, пользователей в системе 10, все они работают
независимо друг от друга, работа пользователей продолжается до тех пор, пока не будет
послан сигнал стоп всем эмуляторам работы пользователя(используйте общую переменную типа
AtomicBoolean).
/**Тут, честно говоря, я не совсем понял в какой момент должна остановиться
работа эмуляторов и сколько их должно всего быть. Возможно надо было создавать EventCreator
исполнительным классом и ещё отдельно класс User который будет создавать события, чтоб из
него уже сделать 10 потоков-эмуляторов. В общем не совсем понял именно эту часть.*/

Существую четыре экземпляра класса FirewallEventListener, которые отвечают за разбор
списка событий создаваемых при работе пользователя. Все четыре обработчика работают
параллельно.
Что делает обработчик:
1. Получает событие из списка событий и записывает его в список логов в виде четырех строк
с интервалом в 1 мс. /**После каждой строчки или после всех 4?*/

"Обработчик " + имя обработчика + eventId + имя пользователя
"Обработчик " + имя обработчика + eventId + ип адрес пользователя
"Обработчик " + имя обработчика + eventId + дата и время запроса
"Обработчик " + имя обработчика + eventId + статус запроса

Обработчики работают пока в списке событий не останется не обработанных событий

После завершения всех обработчиков, отдельный поток должен вывести полученный
список логов в консоль;

Условия для корректного решения:

1. Каждые четыре строки для одного события должны идти подряд и не пересекаться
с другими строками других обработчиков в списке логов
2. Список событий очищать нельзя, каждый обработчик должен понимать какое по счету
событие из списка ему нужно взять
3. Если событие взял обработчик, то его никто более не может взять, в итоговом списке
логов не должно быть одного и того же события обработанных двумя и более обработчиками
4. Не использовать synchronized в сигнатуре методов, в остальных местах можно и нужно.
5. Список событий общий для всех, список логов общий для всех.